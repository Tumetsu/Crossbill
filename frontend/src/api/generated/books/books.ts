/**
 * Generated by orval v7.16.0 ðŸº
 * Do not edit manually.
 * crossbill API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost,
  BookDetails,
  BookUpdateRequest,
  BookWithHighlightCount,
  CoverUploadResponse,
  HTTPValidationError,
  HighlightDeleteRequest,
  HighlightDeleteResponse
} from '.././model';

import { axiosInstance } from '../../axios-instance';




/**
 * Get detailed information about a book including its chapters and highlights.

Args:
    book_id: ID of the book to retrieve
    db: Database session

Returns:
    BookDetails with chapters and their highlights

Raises:
    HTTPException: If book is not found or fetching fails
 * @summary Get Book Details
 */
export const getBookDetailsApiV1BookBookIdGet = (
    bookId: number,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<BookDetails>(
      {url: `/api/v1/book/${bookId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetBookDetailsApiV1BookBookIdGetQueryKey = (bookId?: number,) => {
    return [
    `/api/v1/book/${bookId}`
    ] as const;
    }

    
export const getGetBookDetailsApiV1BookBookIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError = HTTPValidationError>(bookId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBookDetailsApiV1BookBookIdGetQueryKey(bookId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>> = ({ signal }) => getBookDetailsApiV1BookBookIdGet(bookId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(bookId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBookDetailsApiV1BookBookIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>>
export type GetBookDetailsApiV1BookBookIdGetQueryError = HTTPValidationError


export function useGetBookDetailsApiV1BookBookIdGet<TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError = HTTPValidationError>(
 bookId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBookDetailsApiV1BookBookIdGet<TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError = HTTPValidationError>(
 bookId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBookDetailsApiV1BookBookIdGet<TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError = HTTPValidationError>(
 bookId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Book Details
 */

export function useGetBookDetailsApiV1BookBookIdGet<TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError = HTTPValidationError>(
 bookId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBookDetailsApiV1BookBookIdGetQueryOptions(bookId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete a book and all its contents (hard delete).

This will permanently delete the book, all its chapters, and all its highlights.
If the user syncs highlights from the book again, it will recreate the book,
chapters, and highlights.

Args:
    book_id: ID of the book to delete
    db: Database session

Raises:
    HTTPException: If book is not found or deletion fails
 * @summary Delete Book
 */
export const deleteBookApiV1BookBookIdDelete = (
    bookId: number,
 ) => {
      
      
      return axiosInstance<void>(
      {url: `/api/v1/book/${bookId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBookApiV1BookBookIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>, TError,{bookId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>, TError,{bookId: number}, TContext> => {

const mutationKey = ['deleteBookApiV1BookBookIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>, {bookId: number}> = (props) => {
          const {bookId} = props ?? {};

          return  deleteBookApiV1BookBookIdDelete(bookId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBookApiV1BookBookIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>>
    
    export type DeleteBookApiV1BookBookIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Book
 */
export const useDeleteBookApiV1BookBookIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>, TError,{bookId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
        TError,
        {bookId: number},
        TContext
      > => {

      const mutationOptions = getDeleteBookApiV1BookBookIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update book information.

Currently supports updating tags only. The tags will be replaced with the provided list.

Args:
    book_id: ID of the book to update
    request: Book update request containing tags
    db: Database session

Returns:
    Updated book with highlight count and tags

Raises:
    HTTPException: If book is not found or update fails
 * @summary Update Book
 */
export const updateBookApiV1BookBookIdPost = (
    bookId: number,
    bookUpdateRequest: BookUpdateRequest,
 signal?: AbortSignal
) => {
      
      
      return axiosInstance<BookWithHighlightCount>(
      {url: `/api/v1/book/${bookId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bookUpdateRequest, signal
    },
      );
    }
  


export const getUpdateBookApiV1BookBookIdPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>, TError,{bookId: number;data: BookUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>, TError,{bookId: number;data: BookUpdateRequest}, TContext> => {

const mutationKey = ['updateBookApiV1BookBookIdPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>, {bookId: number;data: BookUpdateRequest}> = (props) => {
          const {bookId,data} = props ?? {};

          return  updateBookApiV1BookBookIdPost(bookId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBookApiV1BookBookIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>>
    export type UpdateBookApiV1BookBookIdPostMutationBody = BookUpdateRequest
    export type UpdateBookApiV1BookBookIdPostMutationError = HTTPValidationError

    /**
 * @summary Update Book
 */
export const useUpdateBookApiV1BookBookIdPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>, TError,{bookId: number;data: BookUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
        TError,
        {bookId: number;data: BookUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateBookApiV1BookBookIdPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Soft delete highlights from a book.

This performs a soft delete by marking the highlights as deleted.
When syncing highlights, deleted highlights will not be recreated,
ensuring that user deletions persist across syncs.

Args:
    book_id: ID of the book
    request: Request containing list of highlight IDs to delete
    db: Database session

Returns:
    HighlightDeleteResponse with deletion status and count

Raises:
    HTTPException: If book is not found or deletion fails
 * @summary Delete Highlights
 */
export const deleteHighlightsApiV1BookBookIdHighlightDelete = (
    bookId: number,
    highlightDeleteRequest: HighlightDeleteRequest,
 ) => {
      
      
      return axiosInstance<HighlightDeleteResponse>(
      {url: `/api/v1/book/${bookId}/highlight`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: highlightDeleteRequest
    },
      );
    }
  


export const getDeleteHighlightsApiV1BookBookIdHighlightDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>, TError,{bookId: number;data: HighlightDeleteRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>, TError,{bookId: number;data: HighlightDeleteRequest}, TContext> => {

const mutationKey = ['deleteHighlightsApiV1BookBookIdHighlightDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>, {bookId: number;data: HighlightDeleteRequest}> = (props) => {
          const {bookId,data} = props ?? {};

          return  deleteHighlightsApiV1BookBookIdHighlightDelete(bookId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteHighlightsApiV1BookBookIdHighlightDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>>
    export type DeleteHighlightsApiV1BookBookIdHighlightDeleteMutationBody = HighlightDeleteRequest
    export type DeleteHighlightsApiV1BookBookIdHighlightDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Highlights
 */
export const useDeleteHighlightsApiV1BookBookIdHighlightDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>, TError,{bookId: number;data: HighlightDeleteRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
        TError,
        {bookId: number;data: HighlightDeleteRequest},
        TContext
      > => {

      const mutationOptions = getDeleteHighlightsApiV1BookBookIdHighlightDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Upload a book cover image.

This endpoint accepts an uploaded image file and saves it as the book's cover.
The cover is saved to the covers directory with the filename {book_id}.jpg
and the book's cover field is updated in the database.

Args:
    book_id: ID of the book
    cover: Uploaded image file (JPEG, PNG, etc.)
    db: Database session

Returns:
    Success message with the cover URL

Raises:
    HTTPException: If book is not found or upload fails
 * @summary Upload Book Cover
 */
export const uploadBookCoverApiV1BookBookIdMetadataCoverPost = (
    bookId: number,
    bodyUploadBookCoverApiV1BookBookIdMetadataCoverPost: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`cover`, bodyUploadBookCoverApiV1BookBookIdMetadataCoverPost.cover)

      return axiosInstance<CoverUploadResponse>(
      {url: `/api/v1/book/${bookId}/metadata/cover`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getUploadBookCoverApiV1BookBookIdMetadataCoverPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>, TError,{bookId: number;data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>, TError,{bookId: number;data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost}, TContext> => {

const mutationKey = ['uploadBookCoverApiV1BookBookIdMetadataCoverPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>, {bookId: number;data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost}> = (props) => {
          const {bookId,data} = props ?? {};

          return  uploadBookCoverApiV1BookBookIdMetadataCoverPost(bookId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadBookCoverApiV1BookBookIdMetadataCoverPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>>
    export type UploadBookCoverApiV1BookBookIdMetadataCoverPostMutationBody = BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost
    export type UploadBookCoverApiV1BookBookIdMetadataCoverPostMutationError = HTTPValidationError

    /**
 * @summary Upload Book Cover
 */
export const useUploadBookCoverApiV1BookBookIdMetadataCoverPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>, TError,{bookId: number;data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
        TError,
        {bookId: number;data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost},
        TContext
      > => {

      const mutationOptions = getUploadBookCoverApiV1BookBookIdMetadataCoverPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    