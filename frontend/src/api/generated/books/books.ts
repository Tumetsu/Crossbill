/**
 * Generated by orval v7.16.0 ðŸº
 * Do not edit manually.
 * crossbill API
 * OpenAPI spec version: 0.1.0
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import { useMutation, useQuery } from '@tanstack/react-query';

import type {
  BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost,
  BookDetails,
  BookUpdateRequest,
  BookWithHighlightCount,
  Bookmark,
  BookmarkCreateRequest,
  BookmarksResponse,
  CoverUploadResponse,
  HTTPValidationError,
  Highlight,
  HighlightDeleteRequest,
  HighlightDeleteResponse,
  HighlightTag,
  HighlightTagAssociationRequest,
  HighlightTagCreateRequest,
  HighlightTagUpdateRequest,
  HighlightTagsResponse,
} from '.././model';

import { axiosInstance } from '../../axios-instance';

/**
 * Get detailed information about a book including its chapters and highlights.

Args:
    book_id: ID of the book to retrieve
    db: Database session

Returns:
    BookDetails with chapters and their highlights

Raises:
    HTTPException: If book is not found or fetching fails
 * @summary Get Book Details
 */
export const getBookDetailsApiV1BookBookIdGet = (bookId: number, signal?: AbortSignal) => {
  return axiosInstance<BookDetails>({ url: `/api/v1/book/${bookId}`, method: 'GET', signal });
};

export const getGetBookDetailsApiV1BookBookIdGetQueryKey = (bookId?: number) => {
  return [`/api/v1/book/${bookId}`] as const;
};

export const getGetBookDetailsApiV1BookBookIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBookDetailsApiV1BookBookIdGetQueryKey(bookId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>> = ({
    signal,
  }) => getBookDetailsApiV1BookBookIdGet(bookId, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookDetailsApiV1BookBookIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>
>;
export type GetBookDetailsApiV1BookBookIdGetQueryError = HTTPValidationError;

export function useGetBookDetailsApiV1BookBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookDetailsApiV1BookBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookDetailsApiV1BookBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Book Details
 */

export function useGetBookDetailsApiV1BookBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookDetailsApiV1BookBookIdGetQueryOptions(bookId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a book and all its contents (hard delete).

This will permanently delete the book, all its chapters, and all its highlights.
If the user syncs highlights from the book again, it will recreate the book,
chapters, and highlights.

Args:
    book_id: ID of the book to delete
    db: Database session

Raises:
    HTTPException: If book is not found or deletion fails
 * @summary Delete Book
 */
export const deleteBookApiV1BookBookIdDelete = (bookId: number) => {
  return axiosInstance<void>({ url: `/api/v1/book/${bookId}`, method: 'DELETE' });
};

export const getDeleteBookApiV1BookBookIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
    TError,
    { bookId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
  TError,
  { bookId: number },
  TContext
> => {
  const mutationKey = ['deleteBookApiV1BookBookIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
    { bookId: number }
  > = (props) => {
    const { bookId } = props ?? {};

    return deleteBookApiV1BookBookIdDelete(bookId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteBookApiV1BookBookIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>
>;

export type DeleteBookApiV1BookBookIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Book
 */
export const useDeleteBookApiV1BookBookIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
      TError,
      { bookId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
  TError,
  { bookId: number },
  TContext
> => {
  const mutationOptions = getDeleteBookApiV1BookBookIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update book information.

Currently supports updating tags only. The tags will be replaced with the provided list.

Args:
    book_id: ID of the book to update
    request: Book update request containing tags
    db: Database session

Returns:
    Updated book with highlight count and tags

Raises:
    HTTPException: If book is not found or update fails
 * @summary Update Book
 */
export const updateBookApiV1BookBookIdPost = (
  bookId: number,
  bookUpdateRequest: BookUpdateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<BookWithHighlightCount>({
    url: `/api/v1/book/${bookId}`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: bookUpdateRequest,
    signal,
  });
};

export const getUpdateBookApiV1BookBookIdPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
    TError,
    { bookId: number; data: BookUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
  TError,
  { bookId: number; data: BookUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateBookApiV1BookBookIdPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
    { bookId: number; data: BookUpdateRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return updateBookApiV1BookBookIdPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateBookApiV1BookBookIdPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>
>;
export type UpdateBookApiV1BookBookIdPostMutationBody = BookUpdateRequest;
export type UpdateBookApiV1BookBookIdPostMutationError = HTTPValidationError;

/**
 * @summary Update Book
 */
export const useUpdateBookApiV1BookBookIdPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
      TError,
      { bookId: number; data: BookUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
  TError,
  { bookId: number; data: BookUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateBookApiV1BookBookIdPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Soft delete highlights from a book.

This performs a soft delete by marking the highlights as deleted.
When syncing highlights, deleted highlights will not be recreated,
ensuring that user deletions persist across syncs.

Args:
    book_id: ID of the book
    request: Request containing list of highlight IDs to delete
    db: Database session

Returns:
    HighlightDeleteResponse with deletion status and count

Raises:
    HTTPException: If book is not found or deletion fails
 * @summary Delete Highlights
 */
export const deleteHighlightsApiV1BookBookIdHighlightDelete = (
  bookId: number,
  highlightDeleteRequest: HighlightDeleteRequest
) => {
  return axiosInstance<HighlightDeleteResponse>({
    url: `/api/v1/book/${bookId}/highlight`,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    data: highlightDeleteRequest,
  });
};

export const getDeleteHighlightsApiV1BookBookIdHighlightDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
    TError,
    { bookId: number; data: HighlightDeleteRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
  TError,
  { bookId: number; data: HighlightDeleteRequest },
  TContext
> => {
  const mutationKey = ['deleteHighlightsApiV1BookBookIdHighlightDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
    { bookId: number; data: HighlightDeleteRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return deleteHighlightsApiV1BookBookIdHighlightDelete(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteHighlightsApiV1BookBookIdHighlightDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>
>;
export type DeleteHighlightsApiV1BookBookIdHighlightDeleteMutationBody = HighlightDeleteRequest;
export type DeleteHighlightsApiV1BookBookIdHighlightDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Highlights
 */
export const useDeleteHighlightsApiV1BookBookIdHighlightDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
      TError,
      { bookId: number; data: HighlightDeleteRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
  TError,
  { bookId: number; data: HighlightDeleteRequest },
  TContext
> => {
  const mutationOptions = getDeleteHighlightsApiV1BookBookIdHighlightDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Upload a book cover image.

This endpoint accepts an uploaded image file and saves it as the book's cover.
The cover is saved to the covers directory with the filename {book_id}.jpg
and the book's cover field is updated in the database.

Args:
    book_id: ID of the book
    cover: Uploaded image file (JPEG, PNG, etc.)
    db: Database session

Returns:
    Success message with the cover URL

Raises:
    HTTPException: If book is not found or upload fails
 * @summary Upload Book Cover
 */
export const uploadBookCoverApiV1BookBookIdMetadataCoverPost = (
  bookId: number,
  bodyUploadBookCoverApiV1BookBookIdMetadataCoverPost: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`cover`, bodyUploadBookCoverApiV1BookBookIdMetadataCoverPost.cover);

  return axiosInstance<CoverUploadResponse>({
    url: `/api/v1/book/${bookId}/metadata/cover`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getUploadBookCoverApiV1BookBookIdMetadataCoverPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
    TError,
    { bookId: number; data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
  TError,
  { bookId: number; data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost },
  TContext
> => {
  const mutationKey = ['uploadBookCoverApiV1BookBookIdMetadataCoverPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
    { bookId: number; data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return uploadBookCoverApiV1BookBookIdMetadataCoverPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadBookCoverApiV1BookBookIdMetadataCoverPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>
>;
export type UploadBookCoverApiV1BookBookIdMetadataCoverPostMutationBody =
  BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost;
export type UploadBookCoverApiV1BookBookIdMetadataCoverPostMutationError = HTTPValidationError;

/**
 * @summary Upload Book Cover
 */
export const useUploadBookCoverApiV1BookBookIdMetadataCoverPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
      TError,
      { bookId: number; data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
  TError,
  { bookId: number; data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost },
  TContext
> => {
  const mutationOptions =
    getUploadBookCoverApiV1BookBookIdMetadataCoverPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get all highlight tags for a book.

Args:
    book_id: ID of the book
    db: Database session

Returns:
    List of HighlightTags for the book

Raises:
    HTTPException: If book is not found
 * @summary Get Highlight Tags
 */
export const getHighlightTagsApiV1BookBookIdHighlightTagsGet = (
  bookId: number,
  signal?: AbortSignal
) => {
  return axiosInstance<HighlightTagsResponse>({
    url: `/api/v1/book/${bookId}/highlight_tags`,
    method: 'GET',
    signal,
  });
};

export const getGetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryKey = (bookId?: number) => {
  return [`/api/v1/book/${bookId}/highlight_tags`] as const;
};

export const getGetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryKey(bookId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>
  > = ({ signal }) => getHighlightTagsApiV1BookBookIdHighlightTagsGet(bookId, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>
>;
export type GetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryError = HTTPValidationError;

export function useGetHighlightTagsApiV1BookBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
          TError,
          Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetHighlightTagsApiV1BookBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
          TError,
          Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetHighlightTagsApiV1BookBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Highlight Tags
 */

export function useGetHighlightTagsApiV1BookBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryOptions(
    bookId,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new highlight tag for a book.

Args:
    book_id: ID of the book
    request: Request containing tag name
    db: Database session

Returns:
    Created HighlightTag

Raises:
    HTTPException: If book is not found, tag already exists, or creation fails
 * @summary Create Highlight Tag
 */
export const createHighlightTagApiV1BookBookIdHighlightTagPost = (
  bookId: number,
  highlightTagCreateRequest: HighlightTagCreateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<HighlightTag>({
    url: `/api/v1/book/${bookId}/highlight_tag`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: highlightTagCreateRequest,
    signal,
  });
};

export const getCreateHighlightTagApiV1BookBookIdHighlightTagPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>,
    TError,
    { bookId: number; data: HighlightTagCreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>,
  TError,
  { bookId: number; data: HighlightTagCreateRequest },
  TContext
> => {
  const mutationKey = ['createHighlightTagApiV1BookBookIdHighlightTagPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>,
    { bookId: number; data: HighlightTagCreateRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return createHighlightTagApiV1BookBookIdHighlightTagPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateHighlightTagApiV1BookBookIdHighlightTagPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>
>;
export type CreateHighlightTagApiV1BookBookIdHighlightTagPostMutationBody =
  HighlightTagCreateRequest;
export type CreateHighlightTagApiV1BookBookIdHighlightTagPostMutationError = HTTPValidationError;

/**
 * @summary Create Highlight Tag
 */
export const useCreateHighlightTagApiV1BookBookIdHighlightTagPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>,
      TError,
      { bookId: number; data: HighlightTagCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>,
  TError,
  { bookId: number; data: HighlightTagCreateRequest },
  TContext
> => {
  const mutationOptions =
    getCreateHighlightTagApiV1BookBookIdHighlightTagPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete a highlight tag from a book.

This will also remove the tag from all highlights it was associated with.

Args:
    book_id: ID of the book
    tag_id: ID of the tag to delete
    db: Database session

Raises:
    HTTPException: If tag is not found, doesn't belong to book, or deletion fails
 * @summary Delete Highlight Tag
 */
export const deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete = (
  bookId: number,
  tagId: number
) => {
  return axiosInstance<void>({
    url: `/api/v1/book/${bookId}/highlight_tag/${tagId}`,
    method: 'DELETE',
  });
};

export const getDeleteHighlightTagApiV1BookBookIdHighlightTagTagIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>,
    TError,
    { bookId: number; tagId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>,
  TError,
  { bookId: number; tagId: number },
  TContext
> => {
  const mutationKey = ['deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>,
    { bookId: number; tagId: number }
  > = (props) => {
    const { bookId, tagId } = props ?? {};

    return deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete(bookId, tagId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteHighlightTagApiV1BookBookIdHighlightTagTagIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>
>;

export type DeleteHighlightTagApiV1BookBookIdHighlightTagTagIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Highlight Tag
 */
export const useDeleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>,
      TError,
      { bookId: number; tagId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>,
  TError,
  { bookId: number; tagId: number },
  TContext
> => {
  const mutationOptions =
    getDeleteHighlightTagApiV1BookBookIdHighlightTagTagIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update a highlight tag's name and/or tag group association.

Args:
    book_id: ID of the book
    tag_id: ID of the tag to update
    request: Request containing updated tag information
    db: Database session

Returns:
    Updated HighlightTag

Raises:
    HTTPException: If tag not found, doesn't belong to book, or update fails
 * @summary Update Highlight Tag
 */
export const updateHighlightTagApiV1BookBookIdHighlightTagTagIdPost = (
  bookId: number,
  tagId: number,
  highlightTagUpdateRequest: HighlightTagUpdateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<HighlightTag>({
    url: `/api/v1/book/${bookId}/highlight_tag/${tagId}`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: highlightTagUpdateRequest,
    signal,
  });
};

export const getUpdateHighlightTagApiV1BookBookIdHighlightTagTagIdPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateHighlightTagApiV1BookBookIdHighlightTagTagIdPost>>,
    TError,
    { bookId: number; tagId: number; data: HighlightTagUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateHighlightTagApiV1BookBookIdHighlightTagTagIdPost>>,
  TError,
  { bookId: number; tagId: number; data: HighlightTagUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateHighlightTagApiV1BookBookIdHighlightTagTagIdPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateHighlightTagApiV1BookBookIdHighlightTagTagIdPost>>,
    { bookId: number; tagId: number; data: HighlightTagUpdateRequest }
  > = (props) => {
    const { bookId, tagId, data } = props ?? {};

    return updateHighlightTagApiV1BookBookIdHighlightTagTagIdPost(bookId, tagId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateHighlightTagApiV1BookBookIdHighlightTagTagIdPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateHighlightTagApiV1BookBookIdHighlightTagTagIdPost>>
>;
export type UpdateHighlightTagApiV1BookBookIdHighlightTagTagIdPostMutationBody =
  HighlightTagUpdateRequest;
export type UpdateHighlightTagApiV1BookBookIdHighlightTagTagIdPostMutationError =
  HTTPValidationError;

/**
 * @summary Update Highlight Tag
 */
export const useUpdateHighlightTagApiV1BookBookIdHighlightTagTagIdPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateHighlightTagApiV1BookBookIdHighlightTagTagIdPost>>,
      TError,
      { bookId: number; tagId: number; data: HighlightTagUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateHighlightTagApiV1BookBookIdHighlightTagTagIdPost>>,
  TError,
  { bookId: number; tagId: number; data: HighlightTagUpdateRequest },
  TContext
> => {
  const mutationOptions =
    getUpdateHighlightTagApiV1BookBookIdHighlightTagTagIdPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Add a tag to a highlight.

If a tag name is provided and doesn't exist, it will be created first.
If a tag_id is provided, it will be used directly.

Args:
    book_id: ID of the book
    highlight_id: ID of the highlight
    request: Request containing either tag name or tag_id
    db: Database session

Returns:
    Updated Highlight with tags

Raises:
    HTTPException: If highlight or tag not found, or association fails
 * @summary Add Tag To Highlight
 */
export const addTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPost = (
  bookId: number,
  highlightId: number,
  highlightTagAssociationRequest: HighlightTagAssociationRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<Highlight>({
    url: `/api/v1/book/${bookId}/highlight/${highlightId}/tag`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: highlightTagAssociationRequest,
    signal,
  });
};

export const getAddTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPost>>,
    TError,
    { bookId: number; highlightId: number; data: HighlightTagAssociationRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPost>>,
  TError,
  { bookId: number; highlightId: number; data: HighlightTagAssociationRequest },
  TContext
> => {
  const mutationKey = ['addTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPost>>,
    { bookId: number; highlightId: number; data: HighlightTagAssociationRequest }
  > = (props) => {
    const { bookId, highlightId, data } = props ?? {};

    return addTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPost(bookId, highlightId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof addTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPost>>
>;
export type AddTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPostMutationBody =
  HighlightTagAssociationRequest;
export type AddTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPostMutationError =
  HTTPValidationError;

/**
 * @summary Add Tag To Highlight
 */
export const useAddTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPost>>,
      TError,
      { bookId: number; highlightId: number; data: HighlightTagAssociationRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof addTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPost>>,
  TError,
  { bookId: number; highlightId: number; data: HighlightTagAssociationRequest },
  TContext
> => {
  const mutationOptions =
    getAddTagToHighlightApiV1BookBookIdHighlightHighlightIdTagPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Remove a tag from a highlight.

Args:
    book_id: ID of the book
    highlight_id: ID of the highlight
    tag_id: ID of the tag to remove
    db: Database session

Returns:
    Updated Highlight with tags

Raises:
    HTTPException: If highlight not found or removal fails
 * @summary Remove Tag From Highlight
 */
export const removeTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDelete = (
  bookId: number,
  highlightId: number,
  tagId: number
) => {
  return axiosInstance<Highlight>({
    url: `/api/v1/book/${bookId}/highlight/${highlightId}/tag/${tagId}`,
    method: 'DELETE',
  });
};

export const getRemoveTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof removeTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDelete>
      >,
      TError,
      { bookId: number; highlightId: number; tagId: number },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof removeTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDelete>
    >,
    TError,
    { bookId: number; highlightId: number; tagId: number },
    TContext
  > => {
    const mutationKey = ['removeTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDelete'];
    const { mutation: mutationOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof removeTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDelete>
      >,
      { bookId: number; highlightId: number; tagId: number }
    > = (props) => {
      const { bookId, highlightId, tagId } = props ?? {};

      return removeTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDelete(
        bookId,
        highlightId,
        tagId
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type RemoveTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof removeTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDelete>
    >
  >;

export type RemoveTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Remove Tag From Highlight
 */
export const useRemoveTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof removeTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDelete>
      >,
      TError,
      { bookId: number; highlightId: number; tagId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof removeTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDelete>
  >,
  TError,
  { bookId: number; highlightId: number; tagId: number },
  TContext
> => {
  const mutationOptions =
    getRemoveTagFromHighlightApiV1BookBookIdHighlightHighlightIdTagTagIdDeleteMutationOptions(
      options
    );

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a bookmark for a highlight in a book.

Bookmarks allow users to track their reading progress by marking specific
highlights they want to return to later.

Args:
    book_id: ID of the book
    request: Request containing the highlight_id to bookmark
    db: Database session

Returns:
    Created Bookmark

Raises:
    HTTPException: If book or highlight not found, or creation fails
 * @summary Create Bookmark
 */
export const createBookmarkApiV1BookBookIdBookmarkPost = (
  bookId: number,
  bookmarkCreateRequest: BookmarkCreateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<Bookmark>({
    url: `/api/v1/book/${bookId}/bookmark`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: bookmarkCreateRequest,
    signal,
  });
};

export const getCreateBookmarkApiV1BookBookIdBookmarkPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createBookmarkApiV1BookBookIdBookmarkPost>>,
    TError,
    { bookId: number; data: BookmarkCreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createBookmarkApiV1BookBookIdBookmarkPost>>,
  TError,
  { bookId: number; data: BookmarkCreateRequest },
  TContext
> => {
  const mutationKey = ['createBookmarkApiV1BookBookIdBookmarkPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createBookmarkApiV1BookBookIdBookmarkPost>>,
    { bookId: number; data: BookmarkCreateRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return createBookmarkApiV1BookBookIdBookmarkPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateBookmarkApiV1BookBookIdBookmarkPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createBookmarkApiV1BookBookIdBookmarkPost>>
>;
export type CreateBookmarkApiV1BookBookIdBookmarkPostMutationBody = BookmarkCreateRequest;
export type CreateBookmarkApiV1BookBookIdBookmarkPostMutationError = HTTPValidationError;

/**
 * @summary Create Bookmark
 */
export const useCreateBookmarkApiV1BookBookIdBookmarkPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createBookmarkApiV1BookBookIdBookmarkPost>>,
      TError,
      { bookId: number; data: BookmarkCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createBookmarkApiV1BookBookIdBookmarkPost>>,
  TError,
  { bookId: number; data: BookmarkCreateRequest },
  TContext
> => {
  const mutationOptions = getCreateBookmarkApiV1BookBookIdBookmarkPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete a bookmark from a book.

This operation is idempotent - calling it on a non-existent bookmark
will succeed and return 200 without error.

Args:
    book_id: ID of the book
    bookmark_id: ID of the bookmark to delete
    db: Database session

Raises:
    HTTPException: If book not found or deletion fails
 * @summary Delete Bookmark
 */
export const deleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDelete = (
  bookId: number,
  bookmarkId: number
) => {
  return axiosInstance<unknown>({
    url: `/api/v1/book/${bookId}/bookmark/${bookmarkId}`,
    method: 'DELETE',
  });
};

export const getDeleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDelete>>,
    TError,
    { bookId: number; bookmarkId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDelete>>,
  TError,
  { bookId: number; bookmarkId: number },
  TContext
> => {
  const mutationKey = ['deleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDelete>>,
    { bookId: number; bookmarkId: number }
  > = (props) => {
    const { bookId, bookmarkId } = props ?? {};

    return deleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDelete(bookId, bookmarkId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDelete>>
>;

export type DeleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Bookmark
 */
export const useDeleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDelete>>,
      TError,
      { bookId: number; bookmarkId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDelete>>,
  TError,
  { bookId: number; bookmarkId: number },
  TContext
> => {
  const mutationOptions =
    getDeleteBookmarkApiV1BookBookIdBookmarkBookmarkIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get all bookmarks for a book.

Returns all bookmarks ordered by creation date (newest first).

Args:
    book_id: ID of the book
    db: Database session

Returns:
    List of bookmarks for the book

Raises:
    HTTPException: If book not found or fetching fails
 * @summary Get Bookmarks
 */
export const getBookmarksApiV1BookBookIdBookmarksGet = (bookId: number, signal?: AbortSignal) => {
  return axiosInstance<BookmarksResponse>({
    url: `/api/v1/book/${bookId}/bookmarks`,
    method: 'GET',
    signal,
  });
};

export const getGetBookmarksApiV1BookBookIdBookmarksGetQueryKey = (bookId?: number) => {
  return [`/api/v1/book/${bookId}/bookmarks`] as const;
};

export const getGetBookmarksApiV1BookBookIdBookmarksGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetBookmarksApiV1BookBookIdBookmarksGetQueryKey(bookId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>
  > = ({ signal }) => getBookmarksApiV1BookBookIdBookmarksGet(bookId, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookmarksApiV1BookBookIdBookmarksGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>
>;
export type GetBookmarksApiV1BookBookIdBookmarksGetQueryError = HTTPValidationError;

export function useGetBookmarksApiV1BookBookIdBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
          TError,
          Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookmarksApiV1BookBookIdBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
          TError,
          Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookmarksApiV1BookBookIdBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Bookmarks
 */

export function useGetBookmarksApiV1BookBookIdBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksApiV1BookBookIdBookmarksGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookmarksApiV1BookBookIdBookmarksGetQueryOptions(bookId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
