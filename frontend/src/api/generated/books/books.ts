/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * crossbill API
 * OpenAPI spec version: 0.1.0
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import { useMutation, useQuery } from '@tanstack/react-query';

import type {
  BodyUploadBookCoverApiV1BooksBookIdMetadataCoverPost,
  BookDetails,
  BookHighlightSearchResponse,
  BookUpdateRequest,
  BookWithHighlightCount,
  Bookmark,
  BookmarkCreateRequest,
  BookmarksResponse,
  BooksListResponse,
  CoverUploadResponse,
  FlashcardCreateRequest,
  FlashcardCreateResponse,
  FlashcardsWithHighlightsResponse,
  GetBooksApiV1BooksGetParams,
  GetRecentlyViewedBooksApiV1BooksRecentlyViewedGetParams,
  HTTPValidationError,
  Highlight,
  HighlightDeleteRequest,
  HighlightDeleteResponse,
  HighlightTag,
  HighlightTagAssociationRequest,
  HighlightTagCreateRequest,
  HighlightTagUpdateRequest,
  HighlightTagsResponse,
  RecentlyViewedBooksResponse,
  SearchBookHighlightsApiV1BooksBookIdHighlightsGetParams,
} from '.././model';

import { axiosInstance } from '../../axios-instance';

/**
 * Get all books with their highlight counts, sorted alphabetically by title.

Args:
    db: Database session
    offset: Number of books to skip (for pagination)
    limit: Maximum number of books to return (for pagination)
    search: Optional search text to filter books by title or author

Returns:
    BooksListResponse with list of books and pagination info

Raises:
    HTTPException: If fetching books fails due to server error
 * @summary Get Books
 */
export const getBooksApiV1BooksGet = (
  params?: GetBooksApiV1BooksGetParams,
  signal?: AbortSignal
) => {
  return axiosInstance<BooksListResponse>({ url: `/api/v1/books/`, method: 'GET', params, signal });
};

export const getGetBooksApiV1BooksGetQueryKey = (params?: GetBooksApiV1BooksGetParams) => {
  return [`/api/v1/books/`, ...(params ? [params] : [])] as const;
};

export const getGetBooksApiV1BooksGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBooksApiV1BooksGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBooksApiV1BooksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBooksApiV1BooksGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBooksApiV1BooksGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBooksApiV1BooksGet>>> = ({ signal }) =>
    getBooksApiV1BooksGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBooksApiV1BooksGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBooksApiV1BooksGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBooksApiV1BooksGet>>
>;
export type GetBooksApiV1BooksGetQueryError = HTTPValidationError;

export function useGetBooksApiV1BooksGet<
  TData = Awaited<ReturnType<typeof getBooksApiV1BooksGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetBooksApiV1BooksGetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBooksApiV1BooksGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBooksApiV1BooksGet>>,
          TError,
          Awaited<ReturnType<typeof getBooksApiV1BooksGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBooksApiV1BooksGet<
  TData = Awaited<ReturnType<typeof getBooksApiV1BooksGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBooksApiV1BooksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBooksApiV1BooksGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBooksApiV1BooksGet>>,
          TError,
          Awaited<ReturnType<typeof getBooksApiV1BooksGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBooksApiV1BooksGet<
  TData = Awaited<ReturnType<typeof getBooksApiV1BooksGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBooksApiV1BooksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBooksApiV1BooksGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Books
 */

export function useGetBooksApiV1BooksGet<
  TData = Awaited<ReturnType<typeof getBooksApiV1BooksGet>>,
  TError = HTTPValidationError,
>(
  params?: GetBooksApiV1BooksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBooksApiV1BooksGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBooksApiV1BooksGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get recently viewed books with their highlight counts.

Returns books that have been viewed at least once, ordered by most recently viewed.

Args:
    db: Database session
    limit: Maximum number of books to return (default: 10, max: 50)

Returns:
    RecentlyViewedBooksResponse with list of recently viewed books

Raises:
    HTTPException: If fetching books fails due to server error
 * @summary Get Recently Viewed Books
 */
export const getRecentlyViewedBooksApiV1BooksRecentlyViewedGet = (
  params?: GetRecentlyViewedBooksApiV1BooksRecentlyViewedGetParams,
  signal?: AbortSignal
) => {
  return axiosInstance<RecentlyViewedBooksResponse>({
    url: `/api/v1/books/recently-viewed`,
    method: 'GET',
    params,
    signal,
  });
};

export const getGetRecentlyViewedBooksApiV1BooksRecentlyViewedGetQueryKey = (
  params?: GetRecentlyViewedBooksApiV1BooksRecentlyViewedGetParams
) => {
  return [`/api/v1/books/recently-viewed`, ...(params ? [params] : [])] as const;
};

export const getGetRecentlyViewedBooksApiV1BooksRecentlyViewedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRecentlyViewedBooksApiV1BooksRecentlyViewedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecentlyViewedBooksApiV1BooksRecentlyViewedGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>
  > = ({ signal }) => getRecentlyViewedBooksApiV1BooksRecentlyViewedGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecentlyViewedBooksApiV1BooksRecentlyViewedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>
>;
export type GetRecentlyViewedBooksApiV1BooksRecentlyViewedGetQueryError = HTTPValidationError;

export function useGetRecentlyViewedBooksApiV1BooksRecentlyViewedGet<
  TData = Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | GetRecentlyViewedBooksApiV1BooksRecentlyViewedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
          TError,
          Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRecentlyViewedBooksApiV1BooksRecentlyViewedGet<
  TData = Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRecentlyViewedBooksApiV1BooksRecentlyViewedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
          TError,
          Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRecentlyViewedBooksApiV1BooksRecentlyViewedGet<
  TData = Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRecentlyViewedBooksApiV1BooksRecentlyViewedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Recently Viewed Books
 */

export function useGetRecentlyViewedBooksApiV1BooksRecentlyViewedGet<
  TData = Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
  TError = HTTPValidationError,
>(
  params?: GetRecentlyViewedBooksApiV1BooksRecentlyViewedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentlyViewedBooksApiV1BooksRecentlyViewedGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetRecentlyViewedBooksApiV1BooksRecentlyViewedGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get detailed information about a book including its chapters and highlights.

Args:
    book_id: ID of the book to retrieve
    db: Database session

Returns:
    BookDetails with chapters and their highlights

Raises:
    HTTPException: If book is not found or fetching fails
 * @summary Get Book Details
 */
export const getBookDetailsApiV1BooksBookIdGet = (bookId: number, signal?: AbortSignal) => {
  return axiosInstance<BookDetails>({ url: `/api/v1/books/${bookId}`, method: 'GET', signal });
};

export const getGetBookDetailsApiV1BooksBookIdGetQueryKey = (bookId?: number) => {
  return [`/api/v1/books/${bookId}`] as const;
};

export const getGetBookDetailsApiV1BooksBookIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBookDetailsApiV1BooksBookIdGetQueryKey(bookId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>> = ({
    signal,
  }) => getBookDetailsApiV1BooksBookIdGet(bookId, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookDetailsApiV1BooksBookIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>
>;
export type GetBookDetailsApiV1BooksBookIdGetQueryError = HTTPValidationError;

export function useGetBookDetailsApiV1BooksBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookDetailsApiV1BooksBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookDetailsApiV1BooksBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Book Details
 */

export function useGetBookDetailsApiV1BooksBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BooksBookIdGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookDetailsApiV1BooksBookIdGetQueryOptions(bookId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a book and all its contents (hard delete).

This will permanently delete the book, all its chapters, and all its highlights.
If the user syncs highlights from the book again, it will recreate the book,
chapters, and highlights.

Args:
    book_id: ID of the book to delete
    db: Database session

Raises:
    HTTPException: If book is not found or deletion fails
 * @summary Delete Book
 */
export const deleteBookApiV1BooksBookIdDelete = (bookId: number) => {
  return axiosInstance<void>({ url: `/api/v1/books/${bookId}`, method: 'DELETE' });
};

export const getDeleteBookApiV1BooksBookIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteBookApiV1BooksBookIdDelete>>,
    TError,
    { bookId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteBookApiV1BooksBookIdDelete>>,
  TError,
  { bookId: number },
  TContext
> => {
  const mutationKey = ['deleteBookApiV1BooksBookIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteBookApiV1BooksBookIdDelete>>,
    { bookId: number }
  > = (props) => {
    const { bookId } = props ?? {};

    return deleteBookApiV1BooksBookIdDelete(bookId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteBookApiV1BooksBookIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteBookApiV1BooksBookIdDelete>>
>;

export type DeleteBookApiV1BooksBookIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Book
 */
export const useDeleteBookApiV1BooksBookIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteBookApiV1BooksBookIdDelete>>,
      TError,
      { bookId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteBookApiV1BooksBookIdDelete>>,
  TError,
  { bookId: number },
  TContext
> => {
  const mutationOptions = getDeleteBookApiV1BooksBookIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update book information.

Currently supports updating tags only. The tags will be replaced with the provided list.

Args:
    book_id: ID of the book to update
    request: Book update request containing tags
    db: Database session

Returns:
    Updated book with highlight count and tags

Raises:
    HTTPException: If book is not found or update fails
 * @summary Update Book
 */
export const updateBookApiV1BooksBookIdPost = (
  bookId: number,
  bookUpdateRequest: BookUpdateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<BookWithHighlightCount>({
    url: `/api/v1/books/${bookId}`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: bookUpdateRequest,
    signal,
  });
};

export const getUpdateBookApiV1BooksBookIdPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBookApiV1BooksBookIdPost>>,
    TError,
    { bookId: number; data: BookUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBookApiV1BooksBookIdPost>>,
  TError,
  { bookId: number; data: BookUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateBookApiV1BooksBookIdPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBookApiV1BooksBookIdPost>>,
    { bookId: number; data: BookUpdateRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return updateBookApiV1BooksBookIdPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateBookApiV1BooksBookIdPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateBookApiV1BooksBookIdPost>>
>;
export type UpdateBookApiV1BooksBookIdPostMutationBody = BookUpdateRequest;
export type UpdateBookApiV1BooksBookIdPostMutationError = HTTPValidationError;

/**
 * @summary Update Book
 */
export const useUpdateBookApiV1BooksBookIdPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateBookApiV1BooksBookIdPost>>,
      TError,
      { bookId: number; data: BookUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateBookApiV1BooksBookIdPost>>,
  TError,
  { bookId: number; data: BookUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateBookApiV1BooksBookIdPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Search for highlights in book using full-text search.

Searches across all highlight text using PostgreSQL full-text search.
Results are ranked by relevance and excludes soft-deleted highlights.
 * @summary Search Book Highlights
 */
export const searchBookHighlightsApiV1BooksBookIdHighlightsGet = (
  bookId: number,
  params: SearchBookHighlightsApiV1BooksBookIdHighlightsGetParams,
  signal?: AbortSignal
) => {
  return axiosInstance<BookHighlightSearchResponse>({
    url: `/api/v1/books/${bookId}/highlights`,
    method: 'GET',
    params,
    signal,
  });
};

export const getSearchBookHighlightsApiV1BooksBookIdHighlightsGetQueryKey = (
  bookId?: number,
  params?: SearchBookHighlightsApiV1BooksBookIdHighlightsGetParams
) => {
  return [`/api/v1/books/${bookId}/highlights`, ...(params ? [params] : [])] as const;
};

export const getSearchBookHighlightsApiV1BooksBookIdHighlightsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  params: SearchBookHighlightsApiV1BooksBookIdHighlightsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSearchBookHighlightsApiV1BooksBookIdHighlightsGetQueryKey(bookId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>
  > = ({ signal }) => searchBookHighlightsApiV1BooksBookIdHighlightsGet(bookId, params, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchBookHighlightsApiV1BooksBookIdHighlightsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>
>;
export type SearchBookHighlightsApiV1BooksBookIdHighlightsGetQueryError = HTTPValidationError;

export function useSearchBookHighlightsApiV1BooksBookIdHighlightsGet<
  TData = Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  params: SearchBookHighlightsApiV1BooksBookIdHighlightsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
          TError,
          Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchBookHighlightsApiV1BooksBookIdHighlightsGet<
  TData = Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  params: SearchBookHighlightsApiV1BooksBookIdHighlightsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
          TError,
          Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchBookHighlightsApiV1BooksBookIdHighlightsGet<
  TData = Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  params: SearchBookHighlightsApiV1BooksBookIdHighlightsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Search Book Highlights
 */

export function useSearchBookHighlightsApiV1BooksBookIdHighlightsGet<
  TData = Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  params: SearchBookHighlightsApiV1BooksBookIdHighlightsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchBookHighlightsApiV1BooksBookIdHighlightsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchBookHighlightsApiV1BooksBookIdHighlightsGetQueryOptions(
    bookId,
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Soft delete highlights from a book.

This performs a soft delete by marking the highlights as deleted.
When syncing highlights, deleted highlights will not be recreated,
ensuring that user deletions persist across syncs.

Args:
    book_id: ID of the book
    request: Request containing list of highlight IDs to delete
    db: Database session

Returns:
    HighlightDeleteResponse with deletion status and count

Raises:
    HTTPException: If book is not found or deletion fails
 * @summary Delete Highlights
 */
export const deleteHighlightsApiV1BooksBookIdHighlightDelete = (
  bookId: number,
  highlightDeleteRequest: HighlightDeleteRequest
) => {
  return axiosInstance<HighlightDeleteResponse>({
    url: `/api/v1/books/${bookId}/highlight`,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    data: highlightDeleteRequest,
  });
};

export const getDeleteHighlightsApiV1BooksBookIdHighlightDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteHighlightsApiV1BooksBookIdHighlightDelete>>,
    TError,
    { bookId: number; data: HighlightDeleteRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteHighlightsApiV1BooksBookIdHighlightDelete>>,
  TError,
  { bookId: number; data: HighlightDeleteRequest },
  TContext
> => {
  const mutationKey = ['deleteHighlightsApiV1BooksBookIdHighlightDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteHighlightsApiV1BooksBookIdHighlightDelete>>,
    { bookId: number; data: HighlightDeleteRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return deleteHighlightsApiV1BooksBookIdHighlightDelete(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteHighlightsApiV1BooksBookIdHighlightDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteHighlightsApiV1BooksBookIdHighlightDelete>>
>;
export type DeleteHighlightsApiV1BooksBookIdHighlightDeleteMutationBody = HighlightDeleteRequest;
export type DeleteHighlightsApiV1BooksBookIdHighlightDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Highlights
 */
export const useDeleteHighlightsApiV1BooksBookIdHighlightDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteHighlightsApiV1BooksBookIdHighlightDelete>>,
      TError,
      { bookId: number; data: HighlightDeleteRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteHighlightsApiV1BooksBookIdHighlightDelete>>,
  TError,
  { bookId: number; data: HighlightDeleteRequest },
  TContext
> => {
  const mutationOptions =
    getDeleteHighlightsApiV1BooksBookIdHighlightDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Upload a book cover image.

This endpoint accepts an uploaded image file and saves it as the book's cover.
The cover is saved to the covers directory with the filename {book_id}.jpg
and the book's cover field is updated in the database.

Args:
    book_id: ID of the book
    cover: Uploaded image file (JPEG, PNG, etc.)
    db: Database session

Returns:
    Success message with the cover URL

Raises:
    HTTPException: If book is not found or upload fails
 * @summary Upload Book Cover
 */
export const uploadBookCoverApiV1BooksBookIdMetadataCoverPost = (
  bookId: number,
  bodyUploadBookCoverApiV1BooksBookIdMetadataCoverPost: BodyUploadBookCoverApiV1BooksBookIdMetadataCoverPost,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`cover`, bodyUploadBookCoverApiV1BooksBookIdMetadataCoverPost.cover);

  return axiosInstance<CoverUploadResponse>({
    url: `/api/v1/books/${bookId}/metadata/cover`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getUploadBookCoverApiV1BooksBookIdMetadataCoverPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadBookCoverApiV1BooksBookIdMetadataCoverPost>>,
    TError,
    { bookId: number; data: BodyUploadBookCoverApiV1BooksBookIdMetadataCoverPost },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadBookCoverApiV1BooksBookIdMetadataCoverPost>>,
  TError,
  { bookId: number; data: BodyUploadBookCoverApiV1BooksBookIdMetadataCoverPost },
  TContext
> => {
  const mutationKey = ['uploadBookCoverApiV1BooksBookIdMetadataCoverPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadBookCoverApiV1BooksBookIdMetadataCoverPost>>,
    { bookId: number; data: BodyUploadBookCoverApiV1BooksBookIdMetadataCoverPost }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return uploadBookCoverApiV1BooksBookIdMetadataCoverPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadBookCoverApiV1BooksBookIdMetadataCoverPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadBookCoverApiV1BooksBookIdMetadataCoverPost>>
>;
export type UploadBookCoverApiV1BooksBookIdMetadataCoverPostMutationBody =
  BodyUploadBookCoverApiV1BooksBookIdMetadataCoverPost;
export type UploadBookCoverApiV1BooksBookIdMetadataCoverPostMutationError = HTTPValidationError;

/**
 * @summary Upload Book Cover
 */
export const useUploadBookCoverApiV1BooksBookIdMetadataCoverPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadBookCoverApiV1BooksBookIdMetadataCoverPost>>,
      TError,
      { bookId: number; data: BodyUploadBookCoverApiV1BooksBookIdMetadataCoverPost },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof uploadBookCoverApiV1BooksBookIdMetadataCoverPost>>,
  TError,
  { bookId: number; data: BodyUploadBookCoverApiV1BooksBookIdMetadataCoverPost },
  TContext
> => {
  const mutationOptions =
    getUploadBookCoverApiV1BooksBookIdMetadataCoverPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get the cover image for a book.

This endpoint serves the book cover image with user ownership verification.
Only users who own the book can access its cover.

Args:
    book_id: ID of the book
    db: Database session
    current_user: Authenticated user

Returns:
    FileResponse with the book cover image

Raises:
    HTTPException: If book is not found, user doesn't own it, or cover doesn't exist
 * @summary Get Book Cover
 */
export const getBookCoverApiV1BooksBookIdCoverGet = (bookId: number, signal?: AbortSignal) => {
  return axiosInstance<unknown>({ url: `/api/v1/books/${bookId}/cover`, method: 'GET', signal });
};

export const getGetBookCoverApiV1BooksBookIdCoverGetQueryKey = (bookId?: number) => {
  return [`/api/v1/books/${bookId}/cover`] as const;
};

export const getGetBookCoverApiV1BooksBookIdCoverGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetBookCoverApiV1BooksBookIdCoverGetQueryKey(bookId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>
  > = ({ signal }) => getBookCoverApiV1BooksBookIdCoverGet(bookId, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookCoverApiV1BooksBookIdCoverGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>
>;
export type GetBookCoverApiV1BooksBookIdCoverGetQueryError = HTTPValidationError;

export function useGetBookCoverApiV1BooksBookIdCoverGet<
  TData = Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
          TError,
          Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookCoverApiV1BooksBookIdCoverGet<
  TData = Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
          TError,
          Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookCoverApiV1BooksBookIdCoverGet<
  TData = Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Book Cover
 */

export function useGetBookCoverApiV1BooksBookIdCoverGet<
  TData = Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookCoverApiV1BooksBookIdCoverGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookCoverApiV1BooksBookIdCoverGetQueryOptions(bookId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get all highlight tags for a book.

Args:
    book_id: ID of the book
    db: Database session

Returns:
    List of HighlightTags for the book

Raises:
    HTTPException: If book is not found
 * @summary Get Highlight Tags
 */
export const getHighlightTagsApiV1BooksBookIdHighlightTagsGet = (
  bookId: number,
  signal?: AbortSignal
) => {
  return axiosInstance<HighlightTagsResponse>({
    url: `/api/v1/books/${bookId}/highlight_tags`,
    method: 'GET',
    signal,
  });
};

export const getGetHighlightTagsApiV1BooksBookIdHighlightTagsGetQueryKey = (bookId?: number) => {
  return [`/api/v1/books/${bookId}/highlight_tags`] as const;
};

export const getGetHighlightTagsApiV1BooksBookIdHighlightTagsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetHighlightTagsApiV1BooksBookIdHighlightTagsGetQueryKey(bookId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>
  > = ({ signal }) => getHighlightTagsApiV1BooksBookIdHighlightTagsGet(bookId, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetHighlightTagsApiV1BooksBookIdHighlightTagsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>
>;
export type GetHighlightTagsApiV1BooksBookIdHighlightTagsGetQueryError = HTTPValidationError;

export function useGetHighlightTagsApiV1BooksBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
          TError,
          Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetHighlightTagsApiV1BooksBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
          TError,
          Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetHighlightTagsApiV1BooksBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Highlight Tags
 */

export function useGetHighlightTagsApiV1BooksBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BooksBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetHighlightTagsApiV1BooksBookIdHighlightTagsGetQueryOptions(
    bookId,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new highlight tag for a book.

Args:
    book_id: ID of the book
    request: Request containing tag name
    db: Database session

Returns:
    Created HighlightTag

Raises:
    HTTPException: If book is not found, tag already exists, or creation fails
 * @summary Create Highlight Tag
 */
export const createHighlightTagApiV1BooksBookIdHighlightTagPost = (
  bookId: number,
  highlightTagCreateRequest: HighlightTagCreateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<HighlightTag>({
    url: `/api/v1/books/${bookId}/highlight_tag`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: highlightTagCreateRequest,
    signal,
  });
};

export const getCreateHighlightTagApiV1BooksBookIdHighlightTagPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createHighlightTagApiV1BooksBookIdHighlightTagPost>>,
    TError,
    { bookId: number; data: HighlightTagCreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createHighlightTagApiV1BooksBookIdHighlightTagPost>>,
  TError,
  { bookId: number; data: HighlightTagCreateRequest },
  TContext
> => {
  const mutationKey = ['createHighlightTagApiV1BooksBookIdHighlightTagPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createHighlightTagApiV1BooksBookIdHighlightTagPost>>,
    { bookId: number; data: HighlightTagCreateRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return createHighlightTagApiV1BooksBookIdHighlightTagPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateHighlightTagApiV1BooksBookIdHighlightTagPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createHighlightTagApiV1BooksBookIdHighlightTagPost>>
>;
export type CreateHighlightTagApiV1BooksBookIdHighlightTagPostMutationBody =
  HighlightTagCreateRequest;
export type CreateHighlightTagApiV1BooksBookIdHighlightTagPostMutationError = HTTPValidationError;

/**
 * @summary Create Highlight Tag
 */
export const useCreateHighlightTagApiV1BooksBookIdHighlightTagPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createHighlightTagApiV1BooksBookIdHighlightTagPost>>,
      TError,
      { bookId: number; data: HighlightTagCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createHighlightTagApiV1BooksBookIdHighlightTagPost>>,
  TError,
  { bookId: number; data: HighlightTagCreateRequest },
  TContext
> => {
  const mutationOptions =
    getCreateHighlightTagApiV1BooksBookIdHighlightTagPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete a highlight tag from a book.

This will also remove the tag from all highlights it was associated with.

Args:
    book_id: ID of the book
    tag_id: ID of the tag to delete
    db: Database session

Raises:
    HTTPException: If tag is not found, doesn't belong to book, or deletion fails
 * @summary Delete Highlight Tag
 */
export const deleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDelete = (
  bookId: number,
  tagId: number
) => {
  return axiosInstance<void>({
    url: `/api/v1/books/${bookId}/highlight_tag/${tagId}`,
    method: 'DELETE',
  });
};

export const getDeleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDelete>>,
    TError,
    { bookId: number; tagId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDelete>>,
  TError,
  { bookId: number; tagId: number },
  TContext
> => {
  const mutationKey = ['deleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDelete>>,
    { bookId: number; tagId: number }
  > = (props) => {
    const { bookId, tagId } = props ?? {};

    return deleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDelete(bookId, tagId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDelete>>
>;

export type DeleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Highlight Tag
 */
export const useDeleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDelete>>,
      TError,
      { bookId: number; tagId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDelete>>,
  TError,
  { bookId: number; tagId: number },
  TContext
> => {
  const mutationOptions =
    getDeleteHighlightTagApiV1BooksBookIdHighlightTagTagIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update a highlight tag's name and/or tag group association.

Args:
    book_id: ID of the book
    tag_id: ID of the tag to update
    request: Request containing updated tag information
    db: Database session

Returns:
    Updated HighlightTag

Raises:
    HTTPException: If tag not found, doesn't belong to book, or update fails
 * @summary Update Highlight Tag
 */
export const updateHighlightTagApiV1BooksBookIdHighlightTagTagIdPost = (
  bookId: number,
  tagId: number,
  highlightTagUpdateRequest: HighlightTagUpdateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<HighlightTag>({
    url: `/api/v1/books/${bookId}/highlight_tag/${tagId}`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: highlightTagUpdateRequest,
    signal,
  });
};

export const getUpdateHighlightTagApiV1BooksBookIdHighlightTagTagIdPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateHighlightTagApiV1BooksBookIdHighlightTagTagIdPost>>,
    TError,
    { bookId: number; tagId: number; data: HighlightTagUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateHighlightTagApiV1BooksBookIdHighlightTagTagIdPost>>,
  TError,
  { bookId: number; tagId: number; data: HighlightTagUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateHighlightTagApiV1BooksBookIdHighlightTagTagIdPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateHighlightTagApiV1BooksBookIdHighlightTagTagIdPost>>,
    { bookId: number; tagId: number; data: HighlightTagUpdateRequest }
  > = (props) => {
    const { bookId, tagId, data } = props ?? {};

    return updateHighlightTagApiV1BooksBookIdHighlightTagTagIdPost(bookId, tagId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateHighlightTagApiV1BooksBookIdHighlightTagTagIdPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateHighlightTagApiV1BooksBookIdHighlightTagTagIdPost>>
>;
export type UpdateHighlightTagApiV1BooksBookIdHighlightTagTagIdPostMutationBody =
  HighlightTagUpdateRequest;
export type UpdateHighlightTagApiV1BooksBookIdHighlightTagTagIdPostMutationError =
  HTTPValidationError;

/**
 * @summary Update Highlight Tag
 */
export const useUpdateHighlightTagApiV1BooksBookIdHighlightTagTagIdPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateHighlightTagApiV1BooksBookIdHighlightTagTagIdPost>>,
      TError,
      { bookId: number; tagId: number; data: HighlightTagUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateHighlightTagApiV1BooksBookIdHighlightTagTagIdPost>>,
  TError,
  { bookId: number; tagId: number; data: HighlightTagUpdateRequest },
  TContext
> => {
  const mutationOptions =
    getUpdateHighlightTagApiV1BooksBookIdHighlightTagTagIdPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Add a tag to a highlight.

If a tag name is provided and doesn't exist, it will be created first.
If a tag_id is provided, it will be used directly.

Args:
    book_id: ID of the book
    highlight_id: ID of the highlight
    request: Request containing either tag name or tag_id
    db: Database session

Returns:
    Updated Highlight with tags

Raises:
    HTTPException: If highlight or tag not found, or association fails
 * @summary Add Tag To Highlight
 */
export const addTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPost = (
  bookId: number,
  highlightId: number,
  highlightTagAssociationRequest: HighlightTagAssociationRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<Highlight>({
    url: `/api/v1/books/${bookId}/highlight/${highlightId}/tag`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: highlightTagAssociationRequest,
    signal,
  });
};

export const getAddTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPost>>,
    TError,
    { bookId: number; highlightId: number; data: HighlightTagAssociationRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPost>>,
  TError,
  { bookId: number; highlightId: number; data: HighlightTagAssociationRequest },
  TContext
> => {
  const mutationKey = ['addTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPost>>,
    { bookId: number; highlightId: number; data: HighlightTagAssociationRequest }
  > = (props) => {
    const { bookId, highlightId, data } = props ?? {};

    return addTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPost(bookId, highlightId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof addTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPost>>
  >;
export type AddTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPostMutationBody =
  HighlightTagAssociationRequest;
export type AddTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPostMutationError =
  HTTPValidationError;

/**
 * @summary Add Tag To Highlight
 */
export const useAddTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPost>>,
      TError,
      { bookId: number; highlightId: number; data: HighlightTagAssociationRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof addTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPost>>,
  TError,
  { bookId: number; highlightId: number; data: HighlightTagAssociationRequest },
  TContext
> => {
  const mutationOptions =
    getAddTagToHighlightApiV1BooksBookIdHighlightHighlightIdTagPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Remove a tag from a highlight.

Args:
    book_id: ID of the book
    highlight_id: ID of the highlight
    tag_id: ID of the tag to remove
    db: Database session

Returns:
    Updated Highlight with tags

Raises:
    HTTPException: If highlight not found or removal fails
 * @summary Remove Tag From Highlight
 */
export const removeTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDelete = (
  bookId: number,
  highlightId: number,
  tagId: number
) => {
  return axiosInstance<Highlight>({
    url: `/api/v1/books/${bookId}/highlight/${highlightId}/tag/${tagId}`,
    method: 'DELETE',
  });
};

export const getRemoveTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof removeTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDelete>
      >,
      TError,
      { bookId: number; highlightId: number; tagId: number },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof removeTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDelete>
    >,
    TError,
    { bookId: number; highlightId: number; tagId: number },
    TContext
  > => {
    const mutationKey = [
      'removeTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDelete',
    ];
    const { mutation: mutationOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof removeTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDelete>
      >,
      { bookId: number; highlightId: number; tagId: number }
    > = (props) => {
      const { bookId, highlightId, tagId } = props ?? {};

      return removeTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDelete(
        bookId,
        highlightId,
        tagId
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type RemoveTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof removeTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDelete>
    >
  >;

export type RemoveTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Remove Tag From Highlight
 */
export const useRemoveTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof removeTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDelete>
      >,
      TError,
      { bookId: number; highlightId: number; tagId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof removeTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDelete>
  >,
  TError,
  { bookId: number; highlightId: number; tagId: number },
  TContext
> => {
  const mutationOptions =
    getRemoveTagFromHighlightApiV1BooksBookIdHighlightHighlightIdTagTagIdDeleteMutationOptions(
      options
    );

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a bookmark for a highlight in a book.

Bookmarks allow users to track their reading progress by marking specific
highlights they want to return to later.

Args:
    book_id: ID of the book
    request: Request containing the highlight_id to bookmark
    db: Database session

Returns:
    Created Bookmark

Raises:
    HTTPException: If book or highlight not found, or creation fails
 * @summary Create Bookmark
 */
export const createBookmarkApiV1BooksBookIdBookmarksPost = (
  bookId: number,
  bookmarkCreateRequest: BookmarkCreateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<Bookmark>({
    url: `/api/v1/books/${bookId}/bookmarks`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: bookmarkCreateRequest,
    signal,
  });
};

export const getCreateBookmarkApiV1BooksBookIdBookmarksPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createBookmarkApiV1BooksBookIdBookmarksPost>>,
    TError,
    { bookId: number; data: BookmarkCreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createBookmarkApiV1BooksBookIdBookmarksPost>>,
  TError,
  { bookId: number; data: BookmarkCreateRequest },
  TContext
> => {
  const mutationKey = ['createBookmarkApiV1BooksBookIdBookmarksPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createBookmarkApiV1BooksBookIdBookmarksPost>>,
    { bookId: number; data: BookmarkCreateRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return createBookmarkApiV1BooksBookIdBookmarksPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateBookmarkApiV1BooksBookIdBookmarksPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createBookmarkApiV1BooksBookIdBookmarksPost>>
>;
export type CreateBookmarkApiV1BooksBookIdBookmarksPostMutationBody = BookmarkCreateRequest;
export type CreateBookmarkApiV1BooksBookIdBookmarksPostMutationError = HTTPValidationError;

/**
 * @summary Create Bookmark
 */
export const useCreateBookmarkApiV1BooksBookIdBookmarksPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createBookmarkApiV1BooksBookIdBookmarksPost>>,
      TError,
      { bookId: number; data: BookmarkCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createBookmarkApiV1BooksBookIdBookmarksPost>>,
  TError,
  { bookId: number; data: BookmarkCreateRequest },
  TContext
> => {
  const mutationOptions = getCreateBookmarkApiV1BooksBookIdBookmarksPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get all bookmarks for a book.

Returns all bookmarks ordered by creation date (newest first).

Args:
    book_id: ID of the book
    db: Database session

Returns:
    List of bookmarks for the book

Raises:
    HTTPException: If book not found or fetching fails
 * @summary Get Bookmarks
 */
export const getBookmarksApiV1BooksBookIdBookmarksGet = (bookId: number, signal?: AbortSignal) => {
  return axiosInstance<BookmarksResponse>({
    url: `/api/v1/books/${bookId}/bookmarks`,
    method: 'GET',
    signal,
  });
};

export const getGetBookmarksApiV1BooksBookIdBookmarksGetQueryKey = (bookId?: number) => {
  return [`/api/v1/books/${bookId}/bookmarks`] as const;
};

export const getGetBookmarksApiV1BooksBookIdBookmarksGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetBookmarksApiV1BooksBookIdBookmarksGetQueryKey(bookId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>
  > = ({ signal }) => getBookmarksApiV1BooksBookIdBookmarksGet(bookId, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookmarksApiV1BooksBookIdBookmarksGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>
>;
export type GetBookmarksApiV1BooksBookIdBookmarksGetQueryError = HTTPValidationError;

export function useGetBookmarksApiV1BooksBookIdBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
          TError,
          Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookmarksApiV1BooksBookIdBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
          TError,
          Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookmarksApiV1BooksBookIdBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Bookmarks
 */

export function useGetBookmarksApiV1BooksBookIdBookmarksGet<
  TData = Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookmarksApiV1BooksBookIdBookmarksGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookmarksApiV1BooksBookIdBookmarksGetQueryOptions(bookId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a bookmark from a book.

This operation is idempotent - calling it on a non-existent bookmark
will succeed and return 200 without error.

Args:
    book_id: ID of the book
    bookmark_id: ID of the bookmark to delete
    db: Database session

Raises:
    HTTPException: If book not found or deletion fails
 * @summary Delete Bookmark
 */
export const deleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDelete = (
  bookId: number,
  bookmarkId: number
) => {
  return axiosInstance<unknown>({
    url: `/api/v1/books/${bookId}/bookmarks/${bookmarkId}`,
    method: 'DELETE',
  });
};

export const getDeleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDelete>>,
    TError,
    { bookId: number; bookmarkId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDelete>>,
  TError,
  { bookId: number; bookmarkId: number },
  TContext
> => {
  const mutationKey = ['deleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDelete>>,
    { bookId: number; bookmarkId: number }
  > = (props) => {
    const { bookId, bookmarkId } = props ?? {};

    return deleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDelete(bookId, bookmarkId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDelete>>
>;

export type DeleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Bookmark
 */
export const useDeleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDelete>>,
      TError,
      { bookId: number; bookmarkId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDelete>>,
  TError,
  { bookId: number; bookmarkId: number },
  TContext
> => {
  const mutationOptions =
    getDeleteBookmarkApiV1BooksBookIdBookmarksBookmarkIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a standalone flashcard for a book (without a highlight).

This creates a flashcard that is associated with a book but not tied
to any specific highlight.

Args:
    book_id: ID of the book
    request: Request containing question and answer
    db: Database session

Returns:
    Created flashcard

Raises:
    HTTPException: If book not found or creation fails
 * @summary Create Flashcard For Book
 */
export const createFlashcardForBookApiV1BooksBookIdFlashcardsPost = (
  bookId: number,
  flashcardCreateRequest: FlashcardCreateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<FlashcardCreateResponse>({
    url: `/api/v1/books/${bookId}/flashcards`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: flashcardCreateRequest,
    signal,
  });
};

export const getCreateFlashcardForBookApiV1BooksBookIdFlashcardsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFlashcardForBookApiV1BooksBookIdFlashcardsPost>>,
    TError,
    { bookId: number; data: FlashcardCreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFlashcardForBookApiV1BooksBookIdFlashcardsPost>>,
  TError,
  { bookId: number; data: FlashcardCreateRequest },
  TContext
> => {
  const mutationKey = ['createFlashcardForBookApiV1BooksBookIdFlashcardsPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFlashcardForBookApiV1BooksBookIdFlashcardsPost>>,
    { bookId: number; data: FlashcardCreateRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return createFlashcardForBookApiV1BooksBookIdFlashcardsPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateFlashcardForBookApiV1BooksBookIdFlashcardsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createFlashcardForBookApiV1BooksBookIdFlashcardsPost>>
>;
export type CreateFlashcardForBookApiV1BooksBookIdFlashcardsPostMutationBody =
  FlashcardCreateRequest;
export type CreateFlashcardForBookApiV1BooksBookIdFlashcardsPostMutationError = HTTPValidationError;

/**
 * @summary Create Flashcard For Book
 */
export const useCreateFlashcardForBookApiV1BooksBookIdFlashcardsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createFlashcardForBookApiV1BooksBookIdFlashcardsPost>>,
      TError,
      { bookId: number; data: FlashcardCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createFlashcardForBookApiV1BooksBookIdFlashcardsPost>>,
  TError,
  { bookId: number; data: FlashcardCreateRequest },
  TContext
> => {
  const mutationOptions =
    getCreateFlashcardForBookApiV1BooksBookIdFlashcardsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get all flashcards for a book with embedded highlight data.

Returns all flashcards ordered by creation date (newest first).

Args:
    book_id: ID of the book
    db: Database session

Returns:
    List of flashcards with highlight data for the book

Raises:
    HTTPException: If book not found or fetching fails
 * @summary Get Flashcards For Book
 */
export const getFlashcardsForBookApiV1BooksBookIdFlashcardsGet = (
  bookId: number,
  signal?: AbortSignal
) => {
  return axiosInstance<FlashcardsWithHighlightsResponse>({
    url: `/api/v1/books/${bookId}/flashcards`,
    method: 'GET',
    signal,
  });
};

export const getGetFlashcardsForBookApiV1BooksBookIdFlashcardsGetQueryKey = (bookId?: number) => {
  return [`/api/v1/books/${bookId}/flashcards`] as const;
};

export const getGetFlashcardsForBookApiV1BooksBookIdFlashcardsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFlashcardsForBookApiV1BooksBookIdFlashcardsGetQueryKey(bookId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>
  > = ({ signal }) => getFlashcardsForBookApiV1BooksBookIdFlashcardsGet(bookId, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFlashcardsForBookApiV1BooksBookIdFlashcardsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>
>;
export type GetFlashcardsForBookApiV1BooksBookIdFlashcardsGetQueryError = HTTPValidationError;

export function useGetFlashcardsForBookApiV1BooksBookIdFlashcardsGet<
  TData = Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
          TError,
          Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetFlashcardsForBookApiV1BooksBookIdFlashcardsGet<
  TData = Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
          TError,
          Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetFlashcardsForBookApiV1BooksBookIdFlashcardsGet<
  TData = Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Flashcards For Book
 */

export function useGetFlashcardsForBookApiV1BooksBookIdFlashcardsGet<
  TData = Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFlashcardsForBookApiV1BooksBookIdFlashcardsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetFlashcardsForBookApiV1BooksBookIdFlashcardsGetQueryOptions(
    bookId,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
