/**
 * Generated by orval v7.16.0 ðŸº
 * Do not edit manually.
 * crossbill API
 * OpenAPI spec version: 0.1.0
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import { useMutation, useQuery } from '@tanstack/react-query';

import type {
  BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost,
  BookDetails,
  BookUpdateRequest,
  BookWithHighlightCount,
  CoverUploadResponse,
  HTTPValidationError,
  HighlightDeleteRequest,
  HighlightDeleteResponse,
  HighlightTag,
  HighlightTagCreateRequest,
  HighlightTagsResponse,
} from '.././model';

import { axiosInstance } from '../../axios-instance';

/**
 * Get detailed information about a book including its chapters and highlights.

Args:
    book_id: ID of the book to retrieve
    db: Database session

Returns:
    BookDetails with chapters and their highlights

Raises:
    HTTPException: If book is not found or fetching fails
 * @summary Get Book Details
 */
export const getBookDetailsApiV1BookBookIdGet = (bookId: number, signal?: AbortSignal) => {
  return axiosInstance<BookDetails>({ url: `/api/v1/book/${bookId}`, method: 'GET', signal });
};

export const getGetBookDetailsApiV1BookBookIdGetQueryKey = (bookId?: number) => {
  return [`/api/v1/book/${bookId}`] as const;
};

export const getGetBookDetailsApiV1BookBookIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBookDetailsApiV1BookBookIdGetQueryKey(bookId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>> = ({
    signal,
  }) => getBookDetailsApiV1BookBookIdGet(bookId, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookDetailsApiV1BookBookIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>
>;
export type GetBookDetailsApiV1BookBookIdGetQueryError = HTTPValidationError;

export function useGetBookDetailsApiV1BookBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookDetailsApiV1BookBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookDetailsApiV1BookBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Book Details
 */

export function useGetBookDetailsApiV1BookBookIdGet<
  TData = Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookDetailsApiV1BookBookIdGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookDetailsApiV1BookBookIdGetQueryOptions(bookId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete a book and all its contents (hard delete).

This will permanently delete the book, all its chapters, and all its highlights.
If the user syncs highlights from the book again, it will recreate the book,
chapters, and highlights.

Args:
    book_id: ID of the book to delete
    db: Database session

Raises:
    HTTPException: If book is not found or deletion fails
 * @summary Delete Book
 */
export const deleteBookApiV1BookBookIdDelete = (bookId: number) => {
  return axiosInstance<void>({ url: `/api/v1/book/${bookId}`, method: 'DELETE' });
};

export const getDeleteBookApiV1BookBookIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
    TError,
    { bookId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
  TError,
  { bookId: number },
  TContext
> => {
  const mutationKey = ['deleteBookApiV1BookBookIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
    { bookId: number }
  > = (props) => {
    const { bookId } = props ?? {};

    return deleteBookApiV1BookBookIdDelete(bookId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteBookApiV1BookBookIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>
>;

export type DeleteBookApiV1BookBookIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Book
 */
export const useDeleteBookApiV1BookBookIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
      TError,
      { bookId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteBookApiV1BookBookIdDelete>>,
  TError,
  { bookId: number },
  TContext
> => {
  const mutationOptions = getDeleteBookApiV1BookBookIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update book information.

Currently supports updating tags only. The tags will be replaced with the provided list.

Args:
    book_id: ID of the book to update
    request: Book update request containing tags
    db: Database session

Returns:
    Updated book with highlight count and tags

Raises:
    HTTPException: If book is not found or update fails
 * @summary Update Book
 */
export const updateBookApiV1BookBookIdPost = (
  bookId: number,
  bookUpdateRequest: BookUpdateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<BookWithHighlightCount>({
    url: `/api/v1/book/${bookId}`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: bookUpdateRequest,
    signal,
  });
};

export const getUpdateBookApiV1BookBookIdPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
    TError,
    { bookId: number; data: BookUpdateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
  TError,
  { bookId: number; data: BookUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateBookApiV1BookBookIdPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
    { bookId: number; data: BookUpdateRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return updateBookApiV1BookBookIdPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateBookApiV1BookBookIdPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>
>;
export type UpdateBookApiV1BookBookIdPostMutationBody = BookUpdateRequest;
export type UpdateBookApiV1BookBookIdPostMutationError = HTTPValidationError;

/**
 * @summary Update Book
 */
export const useUpdateBookApiV1BookBookIdPost = <TError = HTTPValidationError, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
      TError,
      { bookId: number; data: BookUpdateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateBookApiV1BookBookIdPost>>,
  TError,
  { bookId: number; data: BookUpdateRequest },
  TContext
> => {
  const mutationOptions = getUpdateBookApiV1BookBookIdPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Soft delete highlights from a book.

This performs a soft delete by marking the highlights as deleted.
When syncing highlights, deleted highlights will not be recreated,
ensuring that user deletions persist across syncs.

Args:
    book_id: ID of the book
    request: Request containing list of highlight IDs to delete
    db: Database session

Returns:
    HighlightDeleteResponse with deletion status and count

Raises:
    HTTPException: If book is not found or deletion fails
 * @summary Delete Highlights
 */
export const deleteHighlightsApiV1BookBookIdHighlightDelete = (
  bookId: number,
  highlightDeleteRequest: HighlightDeleteRequest
) => {
  return axiosInstance<HighlightDeleteResponse>({
    url: `/api/v1/book/${bookId}/highlight`,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    data: highlightDeleteRequest,
  });
};

export const getDeleteHighlightsApiV1BookBookIdHighlightDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
    TError,
    { bookId: number; data: HighlightDeleteRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
  TError,
  { bookId: number; data: HighlightDeleteRequest },
  TContext
> => {
  const mutationKey = ['deleteHighlightsApiV1BookBookIdHighlightDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
    { bookId: number; data: HighlightDeleteRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return deleteHighlightsApiV1BookBookIdHighlightDelete(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteHighlightsApiV1BookBookIdHighlightDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>
>;
export type DeleteHighlightsApiV1BookBookIdHighlightDeleteMutationBody = HighlightDeleteRequest;
export type DeleteHighlightsApiV1BookBookIdHighlightDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Highlights
 */
export const useDeleteHighlightsApiV1BookBookIdHighlightDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
      TError,
      { bookId: number; data: HighlightDeleteRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteHighlightsApiV1BookBookIdHighlightDelete>>,
  TError,
  { bookId: number; data: HighlightDeleteRequest },
  TContext
> => {
  const mutationOptions = getDeleteHighlightsApiV1BookBookIdHighlightDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Upload a book cover image.

This endpoint accepts an uploaded image file and saves it as the book's cover.
The cover is saved to the covers directory with the filename {book_id}.jpg
and the book's cover field is updated in the database.

Args:
    book_id: ID of the book
    cover: Uploaded image file (JPEG, PNG, etc.)
    db: Database session

Returns:
    Success message with the cover URL

Raises:
    HTTPException: If book is not found or upload fails
 * @summary Upload Book Cover
 */
export const uploadBookCoverApiV1BookBookIdMetadataCoverPost = (
  bookId: number,
  bodyUploadBookCoverApiV1BookBookIdMetadataCoverPost: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`cover`, bodyUploadBookCoverApiV1BookBookIdMetadataCoverPost.cover);

  return axiosInstance<CoverUploadResponse>({
    url: `/api/v1/book/${bookId}/metadata/cover`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getUploadBookCoverApiV1BookBookIdMetadataCoverPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
    TError,
    { bookId: number; data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
  TError,
  { bookId: number; data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost },
  TContext
> => {
  const mutationKey = ['uploadBookCoverApiV1BookBookIdMetadataCoverPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
    { bookId: number; data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return uploadBookCoverApiV1BookBookIdMetadataCoverPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadBookCoverApiV1BookBookIdMetadataCoverPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>
>;
export type UploadBookCoverApiV1BookBookIdMetadataCoverPostMutationBody =
  BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost;
export type UploadBookCoverApiV1BookBookIdMetadataCoverPostMutationError = HTTPValidationError;

/**
 * @summary Upload Book Cover
 */
export const useUploadBookCoverApiV1BookBookIdMetadataCoverPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
      TError,
      { bookId: number; data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof uploadBookCoverApiV1BookBookIdMetadataCoverPost>>,
  TError,
  { bookId: number; data: BodyUploadBookCoverApiV1BookBookIdMetadataCoverPost },
  TContext
> => {
  const mutationOptions =
    getUploadBookCoverApiV1BookBookIdMetadataCoverPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get all highlight tags for a book.

Args:
    book_id: ID of the book
    db: Database session

Returns:
    List of HighlightTags for the book

Raises:
    HTTPException: If book is not found
 * @summary Get Highlight Tags
 */
export const getHighlightTagsApiV1BookBookIdHighlightTagsGet = (
  bookId: number,
  signal?: AbortSignal
) => {
  return axiosInstance<HighlightTagsResponse>({
    url: `/api/v1/book/${bookId}/highlight_tags`,
    method: 'GET',
    signal,
  });
};

export const getGetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryKey = (bookId?: number) => {
  return [`/api/v1/book/${bookId}/highlight_tags`] as const;
};

export const getGetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryKey(bookId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>
  > = ({ signal }) => getHighlightTagsApiV1BookBookIdHighlightTagsGet(bookId, signal);

  return { queryKey, queryFn, enabled: !!bookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>
>;
export type GetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryError = HTTPValidationError;

export function useGetHighlightTagsApiV1BookBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
          TError,
          Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetHighlightTagsApiV1BookBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
          TError,
          Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetHighlightTagsApiV1BookBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Highlight Tags
 */

export function useGetHighlightTagsApiV1BookBookIdHighlightTagsGet<
  TData = Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
  TError = HTTPValidationError,
>(
  bookId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getHighlightTagsApiV1BookBookIdHighlightTagsGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetHighlightTagsApiV1BookBookIdHighlightTagsGetQueryOptions(
    bookId,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create a new highlight tag for a book.

Args:
    book_id: ID of the book
    request: Request containing tag name
    db: Database session

Returns:
    Created HighlightTag

Raises:
    HTTPException: If book is not found, tag already exists, or creation fails
 * @summary Create Highlight Tag
 */
export const createHighlightTagApiV1BookBookIdHighlightTagPost = (
  bookId: number,
  highlightTagCreateRequest: HighlightTagCreateRequest,
  signal?: AbortSignal
) => {
  return axiosInstance<HighlightTag>({
    url: `/api/v1/book/${bookId}/highlight_tag`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: highlightTagCreateRequest,
    signal,
  });
};

export const getCreateHighlightTagApiV1BookBookIdHighlightTagPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>,
    TError,
    { bookId: number; data: HighlightTagCreateRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>,
  TError,
  { bookId: number; data: HighlightTagCreateRequest },
  TContext
> => {
  const mutationKey = ['createHighlightTagApiV1BookBookIdHighlightTagPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>,
    { bookId: number; data: HighlightTagCreateRequest }
  > = (props) => {
    const { bookId, data } = props ?? {};

    return createHighlightTagApiV1BookBookIdHighlightTagPost(bookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateHighlightTagApiV1BookBookIdHighlightTagPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>
>;
export type CreateHighlightTagApiV1BookBookIdHighlightTagPostMutationBody =
  HighlightTagCreateRequest;
export type CreateHighlightTagApiV1BookBookIdHighlightTagPostMutationError = HTTPValidationError;

/**
 * @summary Create Highlight Tag
 */
export const useCreateHighlightTagApiV1BookBookIdHighlightTagPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>,
      TError,
      { bookId: number; data: HighlightTagCreateRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createHighlightTagApiV1BookBookIdHighlightTagPost>>,
  TError,
  { bookId: number; data: HighlightTagCreateRequest },
  TContext
> => {
  const mutationOptions =
    getCreateHighlightTagApiV1BookBookIdHighlightTagPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete a highlight tag from a book.

This will also remove the tag from all highlights it was associated with.

Args:
    book_id: ID of the book
    tag_id: ID of the tag to delete
    db: Database session

Raises:
    HTTPException: If tag is not found, doesn't belong to book, or deletion fails
 * @summary Delete Highlight Tag
 */
export const deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete = (
  bookId: number,
  tagId: number
) => {
  return axiosInstance<void>({
    url: `/api/v1/book/${bookId}/highlight_tag/${tagId}`,
    method: 'DELETE',
  });
};

export const getDeleteHighlightTagApiV1BookBookIdHighlightTagTagIdDeleteMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>,
    TError,
    { bookId: number; tagId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>,
  TError,
  { bookId: number; tagId: number },
  TContext
> => {
  const mutationKey = ['deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>,
    { bookId: number; tagId: number }
  > = (props) => {
    const { bookId, tagId } = props ?? {};

    return deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete(bookId, tagId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteHighlightTagApiV1BookBookIdHighlightTagTagIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>
>;

export type DeleteHighlightTagApiV1BookBookIdHighlightTagTagIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Highlight Tag
 */
export const useDeleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>,
      TError,
      { bookId: number; tagId: number },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteHighlightTagApiV1BookBookIdHighlightTagTagIdDelete>>,
  TError,
  { bookId: number; tagId: number },
  TContext
> => {
  const mutationOptions =
    getDeleteHighlightTagApiV1BookBookIdHighlightTagTagIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
